#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <psapi.h>
#include <stdlib.h>

#pragma comment(lib, "psapi.lib")

typedef struct {
    char name[64];
    DWORD rva;
    int syscall_number;
} SyscallEntry;

int CompareSyscallEntries(const void* a, const void* b) {
    const SyscallEntry* entryA = (const SyscallEntry*)a;
    const SyscallEntry* entryB = (const SyscallEntry*)b;
    return (entryA->rva - entryB->rva);
}

int main() {
    HMODULE hNtdll = GetModuleHandle(TEXT("ntdll.dll"));
    if (hNtdll == NULL) {
        printf("Failed to get ntdll handle: %d\n", GetLastError());
        return 1;
    }

    // DOS header
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hNtdll;
    if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
        printf("Invalid DOS header\n");
        return 1;
    }

    // NT headers
    PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((BYTE*)hNtdll + pDosHeader->e_lfanew);
    if (pNtHeaders->Signature != IMAGE_NT_SIGNATURE) {
        printf("Invalid NT header\n");
        return 1;
    }

    // Export directory
    DWORD exportDirRVA = pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    if (exportDirRVA == 0) {
        printf("No export directory found\n");
        return 1;
    }

    PIMAGE_EXPORT_DIRECTORY pExportDir = (PIMAGE_EXPORT_DIRECTORY)((BYTE*)hNtdll + exportDirRVA);

    DWORD* pFunctions = (DWORD*)((BYTE*)hNtdll + pExportDir->AddressOfFunctions);
    DWORD* pNames = (DWORD*)((BYTE*)hNtdll + pExportDir->AddressOfNames);
    WORD* pNameOrdinals = (WORD*)((BYTE*)hNtdll + pExportDir->AddressOfNameOrdinals);

    // Count Zw* functions first
    int zwCount = 0;
    for (DWORD i = 0; i < pExportDir->NumberOfNames; i++) {
        char* pFunctionName = (char*)((BYTE*)hNtdll + pNames[i]);
        if (strncmp(pFunctionName, "Zw", 2) == 0) {
            zwCount++;
        }
    }

    if (zwCount == 0) {
        printf("No Zw* functions found\n");
        return 1;
    }

    // Allocate mem array for syscall entries
    SyscallEntry* syscalls = (SyscallEntry*)malloc(zwCount * sizeof(SyscallEntry));
    if (syscalls == NULL) {
        printf("Memory allocation failed\n");
        return 1;
    }

    // Fill the array with Zw* functions
    int index = 0;
    for (DWORD i = 0; i < pExportDir->NumberOfNames; i++) {
        char* pFunctionName = (char*)((BYTE*)hNtdll + pNames[i]);
        if (strncmp(pFunctionName, "Zw", 2) == 0) {
            strncpy_s(syscalls[index].name, sizeof(syscalls[index].name), pFunctionName, _TRUNCATE);
            syscalls[index].rva = pFunctions[pNameOrdinals[i]];
            index++;
        }
    }

    // Sort by RVA
    qsort(syscalls, zwCount, sizeof(SyscallEntry), CompareSyscallEntries);

    // Assign syscall numbers
    for (int i = 0; i < zwCount; i++) {
        syscalls[i].syscall_number = i;
    }

    printf("NTDLL Syscall Table (sorted by RVA):\n");
    printf("%-30s %-15s %-10s\n", "Function", "RVA", "Syscall #");
    printf("--------------------------------------------------\n");
    for (int i = 0; i < zwCount; i++) {
        printf("%-30s 0x%-13X %-10d\n",
            syscalls[i].name,
            syscalls[i].rva,
            syscalls[i].syscall_number);
    }

    free(syscalls);
    return 0;
}